/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module CompUnsigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = a > b;
    assign \= = a == b;
    assign \< = a < b;
endmodule

module PriorityEncoder4 (
    input in0,
    input in1,
    input in2,
    input in3,
    input in4,
    input in5,
    input in6,
    input in7,
    input in8,
    input in9,
    input in10,
    input in11,
    input in12,
    input in13,
    input in14,
    input in15,
    output reg [3:0] num,
    output any
);
    always @ (*) begin
        if (in15 == 1'b1)
            num = 4'hf;
        else if (in14 == 1'b1)
            num = 4'he;
        else if (in13 == 1'b1)
            num = 4'hd;
        else if (in12 == 1'b1)
            num = 4'hc;
        else if (in11 == 1'b1)
            num = 4'hb;
        else if (in10 == 1'b1)
            num = 4'ha;
        else if (in9 == 1'b1)
            num = 4'h9;
        else if (in8 == 1'b1)
            num = 4'h8;
        else if (in7 == 1'b1)
            num = 4'h7;
        else if (in6 == 1'b1)
            num = 4'h6;
        else if (in5 == 1'b1)
            num = 4'h5;
        else if (in4 == 1'b1)
            num = 4'h4;
        else if (in3 == 1'b1)
            num = 4'h3;
        else if (in2 == 1'b1)
            num = 4'h2;
        else if (in1 == 1'b1)
            num = 4'h1;
        else 
            num = 4'h0;
    end

    assign any = in0 | in1 | in2 | in3 | in4 | in5 | in6 | in7 | in8 | in9 | in10 | in11 | in12 | in13 | in14 | in15;
endmodule


module Mux_16x1_NBits #(
    parameter Bits = 2
)
(
    input [3:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    input [(Bits - 1):0] in_4,
    input [(Bits - 1):0] in_5,
    input [(Bits - 1):0] in_6,
    input [(Bits - 1):0] in_7,
    input [(Bits - 1):0] in_8,
    input [(Bits - 1):0] in_9,
    input [(Bits - 1):0] in_10,
    input [(Bits - 1):0] in_11,
    input [(Bits - 1):0] in_12,
    input [(Bits - 1):0] in_13,
    input [(Bits - 1):0] in_14,
    input [(Bits - 1):0] in_15,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            4'h0: out = in_0;
            4'h1: out = in_1;
            4'h2: out = in_2;
            4'h3: out = in_3;
            4'h4: out = in_4;
            4'h5: out = in_5;
            4'h6: out = in_6;
            4'h7: out = in_7;
            4'h8: out = in_8;
            4'h9: out = in_9;
            4'ha: out = in_10;
            4'hb: out = in_11;
            4'hc: out = in_12;
            4'hd: out = in_13;
            4'he: out = in_14;
            4'hf: out = in_15;
            default:
                out = 'h0;
        endcase
    end
endmodule


module ControlUnit (
  input [5:0] Opcode,
  input Reset, // RESET input
  output aluSrc,
  output RegDst,
  output [2:0] aluOp,
  output memToReg,
  output memRead,
  output memWrite,
  output RegWrite,
  output branch,
  output jump,
  output branch2,
  output lup
);
  wire s0;
  wire s1;
  wire s2;
  wire [3:0] s3;
  wire [12:0] s4;
  wire s5;
  wire s6;
  wire s7;
  wire s8;
  wire s9;
  wire s10;
  wire s11;
  wire s12;
  wire [12:0] s13;
  // rformat
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i0 (
    .a( Opcode ),
    .b( 6'b0 ),
    .\= ( s0 )
  );
  // SW
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i1 (
    .a( Opcode ),
    .b( 6'b101011 ),
    .\= ( s1 )
  );
  // LW
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i2 (
    .a( Opcode ),
    .b( 6'b100011 ),
    .\= ( s2 )
  );
  // Beq
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i3 (
    .a( Opcode ),
    .b( 6'b100 ),
    .\= ( s5 )
  );
  // Bne
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i4 (
    .a( Opcode ),
    .b( 6'b101 ),
    .\= ( s6 )
  );
  // jump
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i5 (
    .a( Opcode ),
    .b( 6'b10 ),
    .\= ( s7 )
  );
  // addi
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i6 (
    .a( Opcode ),
    .b( 6'b1000 ),
    .\= ( s8 )
  );
  // andi
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i7 (
    .a( Opcode ),
    .b( 6'b1100 ),
    .\= ( s9 )
  );
  // ori
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i8 (
    .a( Opcode ),
    .b( 6'b1101 ),
    .\= ( s10 )
  );
  // xori
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i9 (
    .a( Opcode ),
    .b( 6'b1110 ),
    .\= ( s11 )
  );
  // lui
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i10 (
    .a( Opcode ),
    .b( 6'b1111 ),
    .\= ( s12 )
  );
  PriorityEncoder4 PriorityEncoder4_i11 (
    .in0( s0 ),
    .in1( s1 ),
    .in2( s2 ),
    .in3( s5 ),
    .in4( s6 ),
    .in5( s7 ),
    .in6( s8 ),
    .in7( s9 ),
    .in8( s10 ),
    .in9( s11 ),
    .in10( s12 ),
    .in11( 1'b0 ),
    .in12( 1'b0 ),
    .in13( 1'b0 ),
    .in14( 1'b0 ),
    .in15( 1'b0 ),
    .num( s3 )
  );
  Mux_16x1_NBits #(
    .Bits(13)
  )
  Mux_16x1_NBits_i12 (
    .sel( s3 ),
    .in_0( 13'b101111000 ),
    .in_1( 13'b10010001 ),
    .in_2( 13'b110010110 ),
    .in_3( 13'b1000011000 ),
    .in_4( 13'b100000011000 ),
    .in_5( 13'b10000000000 ),
    .in_6( 13'b110010000 ),
    .in_7( 13'b110000000 ),
    .in_8( 13'b110001000 ),
    .in_9( 13'b110101000 ),
    .in_10( 13'b1000110101000 ),
    .in_11( 13'b0 ),
    .in_12( 13'b0 ),
    .in_13( 13'b0 ),
    .in_14( 13'b0 ),
    .in_15( 13'b0 ),
    .out( s4 )
  );
  Mux_2x1_NBits #(
    .Bits(13)
  )
  Mux_2x1_NBits_i13 (
    .sel( Reset ),
    .in_0( s4 ),
    .in_1( 13'b0 ),
    .out( s13 )
  );
  assign memWrite = s13[0];
  assign memRead = s13[1];
  assign memToReg = s13[2];
  assign aluOp = s13[5:3];
  assign RegDst = s13[6];
  assign aluSrc = s13[7];
  assign RegWrite = s13[8];
  assign branch = s13[9];
  assign jump = s13[10];
  assign branch2 = s13[11];
  assign lup = s13[12];
endmodule
module DIG_RegisterFile
#(
    parameter Bits = 8,
    parameter AddrBits = 4
)
(
    input [(Bits-1):0] Din,
    input we,
    input [(AddrBits-1):0] Rw,
    input C,
    input [(AddrBits-1):0] Ra,
    input [(AddrBits-1):0] Rb,
    output [(Bits-1):0] Da,
    output [(Bits-1):0] Db
);

    reg [(Bits-1):0] memory[0:((1 << AddrBits)-1)];

    assign Da = memory[Ra];
    assign Db = memory[Rb];

    always @ (posedge C) begin
        if (we)
            memory[Rw] <= Din;
    end
endmodule

module PriorityEncoder3 (
    input in0,
    input in1,
    input in2,
    input in3,
    input in4,
    input in5,
    input in6,
    input in7,
    output reg [2:0] num,
    output any
);
    always @ (*) begin
        if (in7 == 1'b1)
            num = 3'h7;
        else if (in6 == 1'b1)
            num = 3'h6;
        else if (in5 == 1'b1)
            num = 3'h5;
        else if (in4 == 1'b1)
            num = 3'h4;
        else if (in3 == 1'b1)
            num = 3'h3;
        else if (in2 == 1'b1)
            num = 3'h2;
        else if (in1 == 1'b1)
            num = 3'h1;
        else 
            num = 3'h0;
    end

    assign any = in0 | in1 | in2 | in3 | in4 | in5 | in6 | in7;
endmodule


module ALUControl (
  input [2:0] aluOp,
  input [5:0] Func,
  output [2:0] aluFunc
);
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire s6;
  wire s7;
  wire [2:0] s8;
  wire s9;
  wire [2:0] s10;
  wire s11;
  // ADD
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i0 (
    .a( Func ),
    .b( 6'b100000 ),
    .\= ( s0 )
  );
  // AND
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i1 (
    .a( Func ),
    .b( 6'b100100 ),
    .\= ( s1 )
  );
  // OR
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i2 (
    .a( Func ),
    .b( 6'b100101 ),
    .\= ( s2 )
  );
  // SUB
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i3 (
    .a( Func ),
    .b( 6'b100010 ),
    .\= ( s3 )
  );
  // SLT
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i4 (
    .a( Func ),
    .b( 6'b101010 ),
    .\= ( s4 )
  );
  CompUnsigned #(
    .Bits(3)
  )
  CompUnsigned_i5 (
    .a( aluOp ),
    .b( 3'b111 ),
    .\= ( s11 )
  );
  // xor
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i6 (
    .a( Func ),
    .b( 6'b100110 ),
    .\= ( s5 )
  );
  // mult
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i7 (
    .a( Func ),
    .b( 6'b11000 ),
    .\= ( s6 )
  );
  // div
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i8 (
    .a( Func ),
    .b( 6'b11010 ),
    .\= ( s7 )
  );
  PriorityEncoder3 PriorityEncoder3_i9 (
    .in0( s1 ),
    .in1( s2 ),
    .in2( s0 ),
    .in3( s3 ),
    .in4( s4 ),
    .in5( s5 ),
    .in6( s6 ),
    .in7( s7 ),
    .num( s8 ),
    .any( s9 )
  );
  Mux_2x1_NBits #(
    .Bits(3)
  )
  Mux_2x1_NBits_i10 (
    .sel( s9 ),
    .in_0( 3'b110 ),
    .in_1( s8 ),
    .out( s10 )
  );
  Mux_2x1_NBits #(
    .Bits(3)
  )
  Mux_2x1_NBits_i11 (
    .sel( s11 ),
    .in_0( aluOp ),
    .in_1( s10 ),
    .out( aluFunc )
  );
endmodule
module DIG_RAMDualPort
#(
    parameter Bits = 8,
    parameter AddrBits = 4
)
(
  input [(AddrBits-1):0] A,
  input [(Bits-1):0] Din,
  input str,
  input C,
  input ld,
  output [(Bits-1):0] D
);
  reg [(Bits-1):0] memory[0:((1 << AddrBits) - 1)];

  assign D = ld? memory[A] : 'hz;

  always @ (posedge C) begin
    if (str)
      memory[A] <= Din;
  end
endmodule


module Mux_2x1
(
    input [0:0] sel,
    input in_0,
    input in_1,
    output reg out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule

module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



module DataMemory (
  input [31:0] virtualPC,
  input en,
  output invalidMemory,
  output [10:0] Physicaladdress
);
  wire [31:0] s0;
  wire s1;
  wire s2;
  wire control;
  wire [31:0] s3;
  wire [31:0] s4;
  wire s5;
  wire s6;
  wire adder;
  wire [31:0] s7;
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i0 (
    .a( virtualPC ),
    .b( 32'b10000000000000000001111111111 ),
    .\> ( s1 )
  );
  // DataMem
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i1 (
    .a( virtualPC ),
    .b( 32'b10000000000000000000000000000 ),
    .\< ( s2 )
  );
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i2 (
    .a( virtualPC ),
    .b( 32'b1111111111111111110111111111011 ),
    .\> ( s5 )
  );
  // Stack
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i3 (
    .a( virtualPC ),
    .b( 32'b1111111111111111110101111111100 ),
    .\< ( s6 )
  );
  assign adder = (s6 | s5);
  assign control = (adder & (s2 | s1));
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i4 (
    .sel( control ),
    .in_0( virtualPC ),
    .in_1( 32'b0 ),
    .out( s3 )
  );
  Mux_2x1 Mux_2x1_i5 (
    .sel( en ),
    .in_0( 1'b0 ),
    .in_1( control ),
    .out( invalidMemory )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i6 (
    .sel( en ),
    .in_0( 32'b0 ),
    .in_1( s3 ),
    .out( s4 )
  );
  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i7 (
    .a( s4 ),
    .b( 32'b100 ),
    .c_i( 1'b0 ),
    .s( s7 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i8 (
    .sel( adder ),
    .in_0( s7 ),
    .in_1( s4 ),
    .out( s0 )
  );
  assign Physicaladdress = s0[10:0];
endmodule

module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module DIG_Sub #(
    parameter Bits = 2
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits-1):0] s,
    output c_o
);
    wire [Bits:0] temp;

    assign temp = a - b - c_i;
    assign s = temp[(Bits-1):0];
    assign c_o = temp[Bits];
endmodule


module CompSigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = $signed(a) > $signed(b);
    assign \= = $signed(a) == $signed(b);
    assign \< = $signed(a) < $signed(b);
endmodule


module DIG_Mul_signed #(
    parameter Bits = 1
)
(
    
      input signed [(Bits-1):0] a,
      input signed [(Bits-1):0] b,
      output signed [(Bits*2-1):0] mul
    
);
    assign mul = a * b;
endmodule


module Mux_8x1_NBits #(
    parameter Bits = 2
)
(
    input [2:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    input [(Bits - 1):0] in_4,
    input [(Bits - 1):0] in_5,
    input [(Bits - 1):0] in_6,
    input [(Bits - 1):0] in_7,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            3'h0: out = in_0;
            3'h1: out = in_1;
            3'h2: out = in_2;
            3'h3: out = in_3;
            3'h4: out = in_4;
            3'h5: out = in_5;
            3'h6: out = in_6;
            3'h7: out = in_7;
            default:
                out = 'h0;
        endcase
    end
endmodule


module ALU (
  input [31:0] a,
  input [31:0] b,
  input [2:0] op,
  output [31:0] res,
  output isZero,
  output [31:0] high,
  output [31:0] lo
);
  wire [31:0] s0;
  wire [31:0] s1;
  wire [31:0] s2;
  wire [31:0] s3;
  wire [31:0] s4;
  wire [31:0] s5;
  wire [31:0] res_temp;
  wire s6;
  wire [63:0] s7;
  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i0 (
    .a( a ),
    .b( b ),
    .c_i( 1'b0 ),
    .s( s0 )
  );
  DIG_Sub #(
    .Bits(32)
  )
  DIG_Sub_i1 (
    .a( a ),
    .b( b ),
    .c_i( 1'b0 ),
    .s( s1 )
  );
  assign s2 = (a & b);
  assign s3 = (a | b);
  CompSigned #(
    .Bits(32)
  )
  CompSigned_i2 (
    .a( a ),
    .b( b ),
    .\< ( s6 )
  );
  assign s5 = (a ^ b);
  DIG_Mul_signed #(
    .Bits(32)
  )
  DIG_Mul_signed_i3 (
    .a( a ),
    .b( b ),
    .mul( s7 )
  );
  assign s4[0] = s6;
  assign s4[31:1] = 31'b0;
  assign lo = s7[31:0];
  assign high = s7[63:32];
  Mux_8x1_NBits #(
    .Bits(32)
  )
  Mux_8x1_NBits_i4 (
    .sel( op ),
    .in_0( s2 ),
    .in_1( s3 ),
    .in_2( s0 ),
    .in_3( s1 ),
    .in_4( s4 ),
    .in_5( s5 ),
    .in_6( 32'b0 ),
    .in_7( 32'b0 ),
    .out( res_temp )
  );
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i5 (
    .a( res_temp ),
    .b( 32'b0 ),
    .\= ( isZero )
  );
  assign res = res_temp;
endmodule

module DirVirtual (
  input [31:0] virtualPC,
  output invalidMemory,
  output [9:0] Physicaladdress
);
  wire [31:0] s0;
  wire invalidMemory_temp;
  wire s1;
  wire s2;
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i0 (
    .a( virtualPC ),
    .b( 32'b10000000000001111111111 ),
    .\> ( s1 )
  );
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i1 (
    .a( virtualPC ),
    .b( 32'b10000000000000000000000 ),
    .\< ( s2 )
  );
  assign invalidMemory_temp = (s2 | s1);
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i2 (
    .sel( invalidMemory_temp ),
    .in_0( virtualPC ),
    .in_1( 32'b0 ),
    .out( s0 )
  );
  assign Physicaladdress = s0[9:0];
  assign invalidMemory = invalidMemory_temp;
endmodule
module DIG_ROM_256X32_InstMem (
    input [7:0] A,
    input sel,
    output reg [31:0] D
);
    reg [31:0] my_rom [0:8];

    always @ (*) begin
        if (~sel)
            D = 32'hz;
        else if (A > 8'h8)
            D = 32'h0;
        else
            D = my_rom[A];
    end

    initial begin
        my_rom[0] = 32'h308af0f0;
        my_rom[1] = 32'h8000001;
        my_rom[2] = 32'hac080008;
        my_rom[3] = 32'h0;
        my_rom[4] = 32'h0;
        my_rom[5] = 32'h0;
        my_rom[6] = 32'h0;
        my_rom[7] = 32'h0;
        my_rom[8] = 32'h8000001;
    end
endmodule

module DIG_BitExtender #(
    parameter inputBits = 2,
    parameter outputBits = 4
)
(
    input [(inputBits-1):0] in,
    output [(outputBits - 1):0] out
);
    assign out = {{(outputBits - inputBits){in[inputBits - 1]}}, in};
endmodule




module jtarget (
  input [25:0] jumpadress,
  input [31:0] \pc+4 ,
  output [31:0] out
);
  assign out[1:0] = 2'b0;
  assign out[27:2] = jumpadress;
  assign out[31:28] = \pc+4 [31:28];
endmodule

module muxadd (
  input [5:0] in,
  output out
);
  wire s0;
  wire s1;
  wire s2;
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i0 (
    .a( in ),
    .b( 6'b1100 ),
    .\= ( s0 )
  );
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i1 (
    .a( in ),
    .b( 6'b1101 ),
    .\= ( s1 )
  );
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i2 (
    .a( in ),
    .b( 6'b1110 ),
    .\= ( s2 )
  );
  assign out = (s0 | s1 | s2);
endmodule

module ShiftLeft2 (
  input [31:0] i,
  output [31:0] o
);
  assign o[1:0] = 2'b0;
  assign o[31:2] = i[29:0];
endmodule

module MIPS32SOC (
  input clk,
  input rst,
  output invalid_opcode,
  output invalid_addr,
  output invalid_pc
);
  wire [31:0] s0;
  wire [31:0] s1;
  wire [7:0] s2;
  wire [31:0] s3;
  wire [31:0] pcplus4;
  wire [9:0] s4;
  wire [31:0] s5;
  wire RegWrite;
  wire [4:0] s6;
  wire [4:0] Ra;
  wire [4:0] Rb;
  wire [31:0] s7;
  wire [31:0] s8;
  wire [5:0] Func;
  wire [4:0] s9;
  wire [5:0] Opcode;
  wire [31:0] s10;
  wire [31:0] s11;
  wire [2:0] aluFunc;
  wire [31:0] s12;
  wire isZero;
  wire [31:0] s13;
  wire [31:0] s14;
  wire [15:0] sll16;
  wire [31:0] s15;
  wire aluSrc;
  wire [31:0] s16;
  wire RegDst;
  wire [2:0] aluOp;
  wire memToReg;
  wire memRead;
  wire memWrite;
  wire branch;
  wire jump;
  wire branch2;
  wire lup;
  wire [7:0] s17;
  wire [31:0] s18;
  wire [10:0] s19;
  wire jorbr;
  wire [31:0] offsetgeneral;
  wire [31:0] offset;
  wire [31:0] beqoffset;
  wire [25:0] s20;
  wire [31:0] jumpoffset;
  wire readorwrite;
  wire mxd;
  wire [31:0] s21;
  wire [31:0] s22;
  wire [31:0] reslui;
  wire [31:0] ll;
  wire [31:0] l;
  assign invalid_opcode = 1'b0;
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i0 (
    .sel( rst ),
    .in_0( pcplus4 ),
    .in_1( 32'b10000000000000000000000 ),
    .out( s10 )
  );
  ControlUnit ControlUnit_i1 (
    .Opcode( Opcode ),
    .Reset( rst ),
    .aluSrc( aluSrc ),
    .RegDst( RegDst ),
    .aluOp( aluOp ),
    .memToReg( memToReg ),
    .memRead( memRead ),
    .memWrite( memWrite ),
    .RegWrite( RegWrite ),
    .branch( branch ),
    .jump( jump ),
    .branch2( branch2 ),
    .lup( lup )
  );
  assign readorwrite = (memRead | memWrite);
  // Reg File
  DIG_RegisterFile #(
    .Bits(32),
    .AddrBits(5)
  )
  DIG_RegisterFile_i2 (
    .Din( s5 ),
    .we( RegWrite ),
    .Rw( s6 ),
    .C( clk ),
    .Ra( Ra ),
    .Rb( Rb ),
    .Da( s7 ),
    .Db( s8 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i3 (
    .sel( aluSrc ),
    .in_0( s8 ),
    .in_1( s16 ),
    .out( s11 )
  );
  Mux_2x1_NBits #(
    .Bits(5)
  )
  Mux_2x1_NBits_i4 (
    .sel( RegDst ),
    .in_0( Rb ),
    .in_1( s9 ),
    .out( s6 )
  );
  ALUControl ALUControl_i5 (
    .aluOp( aluOp ),
    .Func( Func ),
    .aluFunc( aluFunc )
  );
  // Data Mem
  DIG_RAMDualPort #(
    .Bits(32),
    .AddrBits(8)
  )
  DIG_RAMDualPort_i6 (
    .A( s17 ),
    .Din( s8 ),
    .str( memWrite ),
    .C( clk ),
    .ld( memRead ),
    .D( s18 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i7 (
    .sel( memToReg ),
    .in_0( s12 ),
    .in_1( s18 ),
    .out( s5 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i8 (
    .sel( jorbr ),
    .in_0( s10 ),
    .in_1( offsetgeneral ),
    .out( s0 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i9 (
    .sel( jump ),
    .in_0( beqoffset ),
    .in_1( jumpoffset ),
    .out( offsetgeneral )
  );
  assign jorbr = (jump | ((branch & isZero) | (branch2 & ~ isZero)));
  DataMemory DataMemory_i10 (
    .virtualPC( s12 ),
    .en( readorwrite ),
    .invalidMemory( invalid_addr ),
    .Physicaladdress( s19 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i11 (
    .sel( lup ),
    .in_0( s22 ),
    .in_1( reslui ),
    .out( s16 )
  );
  // PC
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i12 (
    .D( s0 ),
    .C( clk ),
    .en( 1'b1 ),
    .Q( s1 )
  );
  ALU ALU_i13 (
    .a( s7 ),
    .b( s11 ),
    .op( aluFunc ),
    .res( s12 ),
    .isZero( isZero ),
    .high( s13 ),
    .lo( s14 )
  );
  assign s17 = s19[9:2];
  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i14 (
    .a( s1 ),
    .b( 32'b100 ),
    .c_i( 1'b0 ),
    .s( pcplus4 )
  );
  DirVirtual DirVirtual_i15 (
    .virtualPC( s1 ),
    .invalidMemory( invalid_pc ),
    .Physicaladdress( s4 )
  );
  // High
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i16 (
    .D( s13 ),
    .C( clk ),
    .en( 1'b1 ),
    .Q( ll )
  );
  // Low
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i17 (
    .D( s14 ),
    .C( clk ),
    .en( 1'b1 ),
    .Q( l )
  );
  assign s2 = s4[9:2];
  // InstMem
  DIG_ROM_256X32_InstMem DIG_ROM_256X32_InstMem_i18 (
    .A( s2 ),
    .sel( 1'b1 ),
    .D( s3 )
  );
  assign Func = s3[5:0];
  assign s9 = s3[15:11];
  assign Rb = s3[20:16];
  assign Ra = s3[25:21];
  assign Opcode = s3[31:26];
  assign sll16 = s3[15:0];
  assign s20 = s3[25:0];
  DIG_BitExtender #(
    .inputBits(16),
    .outputBits(32)
  )
  DIG_BitExtender_i19 (
    .in( sll16 ),
    .out( s15 )
  );
  jtarget jtarget_i20 (
    .jumpadress( s20 ),
    .\pc+4 ( pcplus4 ),
    .out( jumpoffset )
  );
  muxadd muxadd_i21 (
    .in( Opcode ),
    .out( mxd )
  );
  assign s21[15:0] = sll16;
  assign s21[31:16] = 16'b0;
  assign reslui[15:0] = 16'b0;
  assign reslui[31:16] = sll16;
  ShiftLeft2 ShiftLeft2_i22 (
    .i( s15 ),
    .o( offset )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i23 (
    .sel( mxd ),
    .in_0( s15 ),
    .in_1( s21 ),
    .out( s22 )
  );
  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i24 (
    .a( pcplus4 ),
    .b( offset ),
    .c_i( 1'b0 ),
    .s( beqoffset )
  );
endmodule
